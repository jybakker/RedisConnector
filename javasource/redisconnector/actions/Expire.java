// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package redisconnector.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import redisconnector.impl.RedisConnector;

/**
 * EXPIRE key seconds
 * 
 * Available since 1.0.0.
 * Time complexity: O(1)
 * Set a timeout on key. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be volatile in Redis terminology.
 * The timeout will only be cleared by commands that delete or overwrite the contents of the key, including DEL, SET, GETSET and all the *STORE commands. This means that all the operations that conceptually alter the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with INCR, pushing a new value into a list with LPUSH, or altering the field value of a hash with HSET are all operations that will leave the timeout untouched.
 * The timeout can also be cleared, turning the key back into a persistent key, using the PERSIST command.
 * If a key is renamed with RENAME, the associated time to live is transferred to the new key name.
 * If a key is overwritten by RENAME, like in the case of an existing key Key_A that is overwritten by a call like RENAME Key_B Key_A, it does not matter if the original Key_A had a timeout associated or not, the new key Key_A will inherit all the characteristics of Key_B.
 * Note that calling EXPIRE/PEXPIRE with a non-positive timeout or EXPIREAT/PEXPIREAT with a time in the past will result in the key being deleted rather than expired (accordingly, the emitted key event will be del, not expired).
 * Refreshing expires
 * It is possible to call EXPIRE using as argument a key that already has an existing expire set. In this case the time to live of a key is updated to the new value. There are many useful applications for this, an example is documented in the Navigation session pattern section below.
 * Differences in Redis prior 2.1.3
 * In Redis versions prior 2.1.3 altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.
 * Return value
 * Integer reply, specifically:
 * 1 if the timeout was set.
 * 0 if key does not exist or the timeout could not be set.
 * Examples
 * redis> SET mykey "Hello"
 * "OK"
 * redis> EXPIRE mykey 10
 * (integer) 1
 * redis> TTL mykey
 * (integer) 10
 * redis> SET mykey "Hello World"
 * "OK"
 * redis> TTL mykey
 * (integer) -1
 * redis> 
 * 
 */
public class Expire extends CustomJavaAction<Long>
{
	private String key;
	private Long seconds;

	public Expire(IContext context, String key, Long seconds)
	{
		super(context);
		this.key = key;
		this.seconds = seconds;
	}

	@Override
	public Long executeAction() throws Exception
	{
		// BEGIN USER CODE
		RedisConnector redisconnector = new RedisConnector(); 
		return redisconnector.expire(key, seconds.intValue());
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public String toString()
	{
		return "Expire";
	}

	// BEGIN EXTRA CODE
	// END EXTRA CODE
}
